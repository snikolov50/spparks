# -*- CMake -*- master configuration file for building SPPARKS
########################################
# CMake build system
# This file is part of SPPARKS
cmake_minimum_required(VERSION 3.20)
########################################
# initialize version variables with project command
if(POLICY CMP0048)
  cmake_policy(SET CMP0048 NEW)
endif()
# set policy to silence warnings about ignoring <PackageName>_ROOT but use it
if(POLICY CMP0074)
  cmake_policy(SET CMP0074 NEW)
endif()
# set policy to silence warnings about ignoring  ${CMAKE_REQUIRED_LIBRARIES} but use it
if(POLICY CMP0075)
  cmake_policy(SET CMP0075 NEW)
endif()
# set policy to silence warnings about requiring execute permission for find_program
# we use OLD because the python-config script for the Fedora MinGW cross-compiler requires it currently
if(POLICY CMP0109)
  cmake_policy(SET CMP0109 OLD)
endif()
# set policy to silence warnings about timestamps of downloaded files. review occasionally if it may be set to NEW
if(POLICY CMP0135)
  cmake_policy(SET CMP0135 OLD)
endif()

########################################

project(spparks
        DESCRIPTION "SPPARKS Kinetic Monte Carlo Simulator"
        HOMEPAGE_URL "https://spparks.github.io/"
        LANGUAGES CXX C)
set(SOVERSION 0)
get_property(BUILD_IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)

include(GNUInstallDirs)
get_filename_component(SPPARKS_DIR ${CMAKE_CURRENT_SOURCE_DIR}/.. ABSOLUTE)
get_filename_component(SPPARKS_LIB_BINARY_DIR ${CMAKE_BINARY_DIR}/lib ABSOLUTE)
# collect all executables and shared libs in the top level build folder
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})

set(SPPARKS_SOURCE_DIR     ${SPPARKS_DIR}/src)
set(SPPARKS_LIB_SOURCE_DIR ${SPPARKS_DIR}/lib)
set(SPPARKS_DOC_DIR        ${SPPARKS_DIR}/doc)
set(SPPARKS_TOOLS_DIR      ${SPPARKS_DIR}/tools)
set(SPPARKS_PYTHON_DIR     ${SPPARKS_DIR}/python)

find_package(Git)

# by default, install into $HOME/.local (not /usr/local), so that no root access (and sudo!!) is needed
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  if((CMAKE_SYSTEM_NAME STREQUAL "Windows") AND (NOT CMAKE_CROSSCOMPILING))
    set(CMAKE_INSTALL_PREFIX "$ENV{USERPROFILE}/SPPARKS" CACHE PATH "Default install path" FORCE)
  else()
    set(CMAKE_INSTALL_PREFIX "$ENV{HOME}/.local" CACHE PATH "Default install path" FORCE)
  endif()
endif()

# If enabled, no need to use LD_LIBRARY_PATH / DYLD_LIBRARY_PATH when installed
option(SPPARKS_INSTALL_RPATH "Set runtime path for shared libraries linked to SPPARKS binaries" OFF)
if(SPPARKS_INSTALL_RPATH)
  set(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_FULL_LIBDIR})
  set(CMAKE_INSTALL_RPATH_USE_LINK_PATH ON)
endif()

# Cmake modules/macros are in a subdirectory to keep this file cleaner
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/Modules)

# make sure LIBRARY_PATH is set if environment variable is set
if(DEFINED ENV{LIBRARY_PATH})
  list(APPEND CMAKE_LIBRARY_PATH "$ENV{LIBRARY_PATH}")
  message(STATUS "Appending $ENV{LIBRARY_PATH} to CMAKE_LIBRARY_PATH: ${CMAKE_LIBRARY_PATH}")
endif()

include(SPPARKSUtils)
get_spparks_version(${SPPARKS_SOURCE_DIR}/version.h PROJECT_VERSION)

include(PreventInSourceBuilds)

if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CXX_FLAGS)
  set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel." FORCE)
endif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CXX_FLAGS)
string(TOUPPER "${CMAKE_BUILD_TYPE}" BTYPE)

# check for files auto-generated by make-based buildsystem
# this is fast, so check for it all the time
message(${SPPARKS_SOURCE_DIR})
check_for_autogen_files(${SPPARKS_SOURCE_DIR})

######################################################################
# compiler tests
# these need ot be done early (before further tests).
#####################################################################
include(CheckIncludeFileCXX)

# set required compiler flags and compiler/CPU arch specific optimizations
if(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
  if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    if(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Qrestrict")
    endif()
    if(CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.3 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.4)
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /QxCOMMON-AVX512")
    else()
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /QxHost")
    endif()
  else()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -restrict")
    if(CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.3 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.4)
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -xCOMMON-AVX512")
    else()
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -xHost -fp-model fast=2 -no-prec-div -qoverride-limits -diag-disable=10441 -diag-disable=11074 -diag-disable=11076 -diag-disable=2196")
    endif()
  endif()
endif()

# silence excessive warnings for new Intel Compilers
if(CMAKE_CXX_COMPILER_ID STREQUAL "IntelLLVM")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fp-model precise -Wno-tautological-constant-compare -Wno-unused-command-line-argument")
endif()

# silence excessive warnings for PGI/NVHPC compilers
if((CMAKE_CXX_COMPILER_ID STREQUAL "NVHPC") OR (CMAKE_CXX_COMPILER_ID STREQUAL "PGI"))
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Minform=severe")
endif()

# silence nvcc warnings when using nvcc_wrapper
get_filename_component(SPPARKS_CXX_COMPILER_NAME "${CMAKE_CXX_COMPILER}" NAME CACHE)

# We *require* C++17 without extensions
# Kokkos also requires at least C++17 (currently)
if(NOT CMAKE_CXX_STANDARD)
# uncomment in case we plan to switch to C++20 as minimum standard
#  if(cxx_std_20 IN_LIST CMAKE_CXX_COMPILE_FEATURES)
#    set(CMAKE_CXX_STANDARD 20)
#  else()
    set(CMAKE_CXX_STANDARD 17)
#  endif()
endif()
if(CMAKE_CXX_STANDARD LESS 17)
  message(FATAL_ERROR "C++ standard must be set to at least 17")
endif()

set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF CACHE BOOL "Use compiler extensions")
# ugly hacks for MSVC which by default always reports an old C++ standard in the __cplusplus macro
# and prints lots of pointless warnings about "unsafe" functions
if(MSVC)
  if((CMAKE_CXX_COMPILER_ID STREQUAL "MSVC") OR (CMAKE_CXX_COMPILER_ID STREQUAL "Intel"))
    add_compile_options(/Zc:__cplusplus)
    add_compile_options(/wd4244)
    add_compile_options(/wd4267)
    add_compile_options(/wd4250)
    add_compile_options(/EHsc)
    add_compile_options(/utf-8)
  endif()
  add_compile_definitions(_CRT_SECURE_NO_WARNINGS)
endif()

# warn about potentially problematic GCC compiler versions
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
  if (CMAKE_CXX_STANDARD GREATER_EQUAL 17)
    if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.3)
      message(WARNING "Using the GNU compilers version ${CMAKE_CXX_COMPILER_VERSION} with C++17 "
              "or later is not recommended. Please use the GNU compilers version 9.3 or later")
    endif()
  endif()
endif()

# export all symbols when building a .dll file on windows
if((CMAKE_SYSTEM_NAME STREQUAL "Windows") AND BUILD_SHARED_LIBS)
  set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
endif()

# do not include the (obsolete) MPI C++ bindings which makes for leaner object files
# and avoids namespace conflicts. Put this early to increase its visbility.
set(MPI_CXX_SKIP_MPICXX TRUE CACHE BOOL "Skip MPI C++ Bindings" FORCE)

########################################################################
# User input options                                                   #
########################################################################
# backward compatibility with older SPPARKS documentation
if (PYTHON_EXECUTABLE)
  set(Python_EXECUTABLE "${PYTHON_EXECUTABLE}")
endif()
# set path to python interpreter and thus enforcing python version when
# in a virtual environment and Python_EXECUTABLE is not set on command line
if(DEFINED ENV{VIRTUAL_ENV} AND NOT Python_EXECUTABLE)
  if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
    set(Python_EXECUTABLE "$ENV{VIRTUAL_ENV}/Scripts/python.exe")
  else()
    set(Python_EXECUTABLE "$ENV{VIRTUAL_ENV}/bin/python")
  endif()
  message(STATUS "Running in virtual environment: $ENV{VIRTUAL_ENV}\n"
    "   Setting Python interpreter to: ${Python_EXECUTABLE}")
endif()

find_package(Python COMPONENTS Interpreter QUIET)
# NOTE: RHEL 8.0 and Ubuntu 18.04LTS ship with Python 3.6, Python 3.8 was EOL in 2024
if(Python_VERSION VERSION_LESS 3.6)
  message(FATAL_ERROR "SPPARKS requires Python 3.6 or later")
endif()

set(SPPARKS_MACHINE "" CACHE STRING "Suffix to append to spk binary (WON'T enable any features automatically")
mark_as_advanced(SPPARKS_MACHINE)
if(SPPARKS_MACHINE)
  set(SPPARKS_MACHINE "_${SPPARKS_MACHINE}")
endif()
set(SPPARKS_BINARY spk${SPPARKS_MACHINE})

option(BUILD_SHARED_LIBS "Build shared library" OFF)
option(CMAKE_POSITION_INDEPENDENT_CODE "Create object compatible with shared libraries" ON)

file(GLOB ALL_SOURCES CONFIGURE_DEPENDS ${SPPARKS_SOURCE_DIR}/[^.]*.cpp)
file(GLOB MAIN_SOURCES CONFIGURE_DEPENDS ${SPPARKS_SOURCE_DIR}/main.cpp)
list(REMOVE_ITEM ALL_SOURCES ${MAIN_SOURCES})
add_library(spparks ${ALL_SOURCES})

# add extra libraries for std::filesystem with older compilers
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.1)
  target_link_libraries(spparks PRIVATE stdc++fs)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.0)
  target_link_libraries(spparks PRIVATE c++fs)
endif()

# tell CMake to export all symbols to a .dll on Windows with MinGW cross-compilers
if(BUILD_SHARED_LIBS AND (CMAKE_SYSTEM_NAME STREQUAL "Windows") AND CMAKE_CROSSCOMPILING)
  set_target_properties(spparks PROPERTIES LINK_FLAGS "-Wl,--export-all-symbols")
endif()

add_executable(spk ${MAIN_SOURCES})
target_link_libraries(spk PRIVATE spparks)
set_target_properties(spk PROPERTIES OUTPUT_NAME ${SPPARKS_BINARY})
# re-export all symbols for plugins
if(PKG_PLUGIN AND (NOT ((CMAKE_SYSTEM_NAME STREQUAL "Windows"))))
  set_target_properties(spk PROPERTIES ENABLE_EXPORTS TRUE)
endif()
install(TARGETS spk EXPORT SPPARKS_Targets DESTINATION ${CMAKE_INSTALL_BINDIR})

option(CMAKE_VERBOSE_MAKEFILE "Generate verbose Makefiles" OFF)

set(STANDARD_PACKAGES STITCH)

set(SUFFIX_PACKAGES potts_quaternion)

foreach(PKG ${STANDARD_PACKAGES} ${SUFFIX_PACKAGES})
  option(PKG_${PKG} "Build ${PKG} Package" OFF)
endforeach()

######################################################
# packages with special compiler needs or external libs
######################################################
target_include_directories(spparks PUBLIC $<BUILD_INTERFACE:${SPPARKS_SOURCE_DIR}>)
target_include_directories(spparks PUBLIC $<BUILD_INTERFACE:${SPPARKS_THIRDPARTY_DIR}>)

if(NOT CMAKE_CROSSCOMPILING)
  find_package(MPI QUIET COMPONENTS CXX)
  option(BUILD_MPI "Build MPI version" ${MPI_FOUND})
else()
  option(BUILD_MPI "Build MPI version" OFF)
endif()

if(BUILD_MPI)
  # We use a non-standard procedure to cross-compile with MPI on Windows
  if((CMAKE_SYSTEM_NAME STREQUAL "Windows") AND CMAKE_CROSSCOMPILING)
    include(MPI4WIN)
  else()
    find_package(MPI REQUIRED COMPONENTS CXX)
    option(SPPARKS_LONGLONG_TO_LONG "Workaround if your system or MPI version does not recognize 'long long' data types" OFF)
    if(SPPARKS_LONGLONG_TO_LONG)
      target_compile_definitions(spparks PRIVATE -DSPPARKS_LONGLONG_TO_LONG)
    endif()
  endif()
  target_link_libraries(spparks PUBLIC MPI::MPI_CXX)
else()
  target_sources(spparks PRIVATE ${SPPARKS_SOURCE_DIR}/STUBS/mpi.cpp)
  add_library(mpi_stubs INTERFACE)
  target_include_directories(mpi_stubs INTERFACE $<BUILD_INTERFACE:${SPPARKS_SOURCE_DIR}/STUBS>)
  target_link_libraries(spparks PUBLIC mpi_stubs)
endif()

set(SPPARKS_SIZES "smallbig" CACHE STRING "SPPARKS integer sizes (smallbig: 64-bit #atoms #timesteps, bigbig: also 64-bit imageint, 64-bit atom ids)")
set(SPPARKS_SIZES_VALUES smallbig bigbig)
set_property(CACHE SPPARKS_SIZES PROPERTY STRINGS ${SPPARKS_SIZES_VALUES})
validate_option(SPPARKS_SIZES SPPARKS_SIZES_VALUES)
string(TOUPPER ${SPPARKS_SIZES} SPPARKS_SIZES)
target_compile_definitions(spparks PUBLIC -DSPPARKS_${SPPARKS_SIZES})

# posix_memalign is not available on Windows
# with INTEL package and Intel compilers we use TBB's aligned malloc
if((CMAKE_SYSTEM_NAME STREQUAL "Windows")
   AND NOT (PKG_INTEL AND ((CMAKE_CXX_COMPILER_ID STREQUAL "Intel") OR (CMAKE_CXX_COMPILER_ID STREQUAL "IntelLLVM"))))
  set(SPPARKS_MEMALIGN "0" CACHE STRING "posix_memalign() is not available on Windows" FORCE)
else()
  set(SPPARKS_MEMALIGN "64" CACHE STRING "enables the use of the posix_memalign() call instead of malloc() when large chunks or memory are allocated by SPPARKS. Set to 0 to disable")
endif()
if(NOT ${SPPARKS_MEMALIGN} STREQUAL "0")
  target_compile_definitions(spparks PRIVATE -DSPPARKS_MEMALIGN=${SPPARKS_MEMALIGN})
endif()

# this hack is required to compile fmt lib with CrayClang version 15.0.2
# CrayClang is only directly recognized by CMake version 3.28 and later
if(CMAKE_VERSION VERSION_LESS 3.28)
  get_filename_component(_exe "${CMAKE_CXX_COMPILER}" NAME)
  if((CMAKE_CXX_COMPILER_ID STREQUAL "Clang") AND (_exe STREQUAL "crayCC"))
    target_compile_definitions(spparks PRIVATE -DFMT_STATIC_THOUSANDS_SEPARATOR)
  endif()
else()
  if(CMAKE_CXX_COMPILER_ID STREQUAL "CrayClang")
    target_compile_definitions(spparks PRIVATE -DFMT_STATIC_THOUSANDS_SEPARATOR)
  endif()
endif()

# "hard" dependencies between packages resulting
# in an error instead of skipping over files
#pkg_depends(ML-IAP ML-SNAP)

# detect if we may enable OpenMP support by default
set(BUILD_OMP_DEFAULT OFF)
find_package(OpenMP COMPONENTS CXX QUIET)
if(OpenMP_CXX_FOUND)
  check_omp_h_include()
  if(HAVE_OMP_H_INCLUDE)
    set(BUILD_OMP_DEFAULT ON)
  endif()
endif()

option(BUILD_OMP "Build with OpenMP support" ${BUILD_OMP_DEFAULT})

if(BUILD_OMP)
  find_package(OpenMP COMPONENTS CXX REQUIRED)
  check_omp_h_include()
  if(NOT HAVE_OMP_H_INCLUDE)
    message(FATAL_ERROR "Cannot find the 'omp.h' header file required for full OpenMP support")
  endif()

  if(((CMAKE_CXX_COMPILER_ID STREQUAL "GNU") AND (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 9.0)) OR
      (CMAKE_CXX_COMPILER_ID STREQUAL "PGI") OR (CMAKE_CXX_COMPILER_ID STREQUAL "NVHPC") OR
      (CMAKE_CXX_COMPILER_ID STREQUAL "IntelLLVM") OR (CMAKE_CXX_COMPILER_ID STREQUAL "XLClang") OR
      ((CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang") AND (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 10.0)) OR
      ((CMAKE_CXX_COMPILER_ID STREQUAL "Clang") AND (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 10.0)) OR
      ((CMAKE_CXX_COMPILER_ID STREQUAL "CrayClang") AND (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 10.0)) OR
      ((CMAKE_CXX_COMPILER_ID STREQUAL "Intel") AND (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 19.0)))
    # GCC 9.x and later plus Clang 10.x and later implement strict OpenMP 4.0 semantics for consts.
    # Intel 18.0 was tested to support both, so we switch to OpenMP 4+ from 19.x onward to be safe.
    set(SPPARKS_OMP_COMPAT_LEVEL 4)
  else()
    set(SPPARKS_OMP_COMPAT_LEVEL 3)
  endif()
  target_compile_definitions(spparks PRIVATE -DSPPARKS_OMP_COMPAT=${SPPARKS_OMP_COMPAT_LEVEL})
  target_link_libraries(spparks PRIVATE OpenMP::OpenMP_CXX)
  target_link_libraries(spk PRIVATE OpenMP::OpenMP_CXX)

  # this hack is required to correctly link with OpenMP support when using CrayClang version 15.0.2
  # CrayClang is only directly recognized by version 3.28 and later
  if(CMAKE_VERSION VERSION_LESS 3.28)
    get_filename_component(_exe "${CMAKE_CXX_COMPILER}" NAME)
    if((CMAKE_CXX_COMPILER_ID STREQUAL "Clang") AND (_exe STREQUAL "crayCC"))
      set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fopenmp")
      set(CMAKE_STATIC_LINKER_FLAGS "${CMAKE_STATIC_LINKER_FLAGS} -fopenmp")
    endif()
  else()
    if(CMAKE_CXX_COMPILER_ID STREQUAL "CrayClang")
      set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fopenmp")
      set(CMAKE_STATIC_LINKER_FLAGS "${CMAKE_STATIC_LINKER_FLAGS} -fopenmp")
    endif()
  endif()
endif()

# lower C++ standard for fmtlib sources when using Intel classic compiler
if((CMAKE_CXX_COMPILER_ID STREQUAL "Intel") AND (CMAKE_CXX_STANDARD GREATER_EQUAL 17)
    AND (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 2021.10))
  message(STATUS "Lowering C++ standard for compiling fmtlib sources with Intel Classic compiler")
  get_filename_component(LMP_UTILS_SRC "${SPPARKS_SOURCE_DIR}/utils.cpp" ABSOLUTE)
  get_filename_component(LMP_VARIABLE_SRC "${SPPARKS_SOURCE_DIR}/variable.cpp" ABSOLUTE)
  get_filename_component(FMT_FORMAT_SRC "${SPPARKS_SOURCE_DIR}/fmtlib_format.cpp" ABSOLUTE)
  get_filename_component(FMT_OS_SRC "${SPPARKS_SOURCE_DIR}/fmtlib_os.cpp" ABSOLUTE)
  set_source_files_properties("${FMT_FORMAT_SRC}" "${FMT_OS_SRC}" "${LMP_VARIABLE_SRC}" "${LMP_UTILS_SRC}"
          PROPERTIES COMPILE_OPTIONS "-std=c++14")
endif()

if(PKG_ML-QUIP OR PKG_ML-POD OR PKG_ELECTRODE OR PKG_RHEO OR BUILD_TOOLS)
  if (NOT USE_INTERNAL_LINALG)
    find_package(LAPACK)
    find_package(BLAS)
  endif()
  if(NOT LAPACK_FOUND OR NOT BLAS_FOUND OR USE_INTERNAL_LINALG)
    file(GLOB LINALG_SOURCES CONFIGURE_DEPENDS ${SPPARKS_LIB_SOURCE_DIR}/linalg/[^.]*.cpp)
    add_library(linalg STATIC ${LINALG_SOURCES})
    set_target_properties(linalg PROPERTIES OUTPUT_NAME spparks_linalg${SPPARKS_MACHINE})
    set(BLAS_LIBRARIES "$<TARGET_FILE:linalg>")
    set(LAPACK_LIBRARIES "$<TARGET_FILE:linalg>")
    target_link_libraries(spparks PRIVATE linalg)
  else()
    list(APPEND LAPACK_LIBRARIES ${BLAS_LIBRARIES})
  endif()
endif()

# tweak jpeg library names to avoid linker errors with MinGW cross-compilation
set(JPEG_NAMES libjpeg libjpeg-62)
find_package(JPEG QUIET)
option(WITH_JPEG "Enable JPEG support" ${JPEG_FOUND})
if(WITH_JPEG)
  find_package(JPEG REQUIRED)
  target_compile_definitions(spparks PRIVATE -DSPPARKS_JPEG)
  target_link_libraries(spparks PRIVATE JPEG::JPEG)
endif()

find_package(PNG QUIET)
find_package(ZLIB QUIET)
if(PNG_FOUND AND ZLIB_FOUND)
  option(WITH_PNG "Enable PNG support" ON)
else()
  option(WITH_PNG "Enable PNG support" OFF)
endif()
if(WITH_PNG)
  find_package(PNG REQUIRED)
  find_package(ZLIB REQUIRED)
  target_link_libraries(spparks PRIVATE PNG::PNG ZLIB::ZLIB)
  target_compile_definitions(spparks PRIVATE -DSPPARKS_PNG)
endif()

find_program(GZIP_EXECUTABLE gzip)
find_package_handle_standard_args(GZIP REQUIRED_VARS GZIP_EXECUTABLE)
option(WITH_GZIP "Enable GZIP support" ${GZIP_FOUND})
if(WITH_GZIP)
  if(GZIP_FOUND OR ((CMAKE_SYSTEM_NAME STREQUAL "Windows") AND CMAKE_CROSSCOMPILING))
    target_compile_definitions(spparks PRIVATE -DSPPARKS_GZIP)
  else()
    message(FATAL_ERROR "gzip executable not found")
  endif()
endif()

find_program(FFMPEG_EXECUTABLE ffmpeg)
find_package_handle_standard_args(FFMPEG REQUIRED_VARS FFMPEG_EXECUTABLE)
option(WITH_FFMPEG "Enable FFMPEG support" ${FFMPEG_FOUND})
if(WITH_FFMPEG)
  if(FFMPEG_FOUND OR ((CMAKE_SYSTEM_NAME STREQUAL "Windows") AND CMAKE_CROSSCOMPILING))
    target_compile_definitions(spparks PRIVATE -DSPPARKS_FFMPEG)
  else()
    message(FATAL_ERROR "ffmpeg executable not found")
  endif()
endif()

if(BUILD_SHARED_LIBS)
  set(CONFIGURE_REQUEST_PIC "--with-pic")
  set(CMAKE_REQUEST_PIC "-DCMAKE_POSITION_INDEPENDENT_CODE=${CMAKE_POSITION_INDEPENDENT_CODE}")
else()
  set(CONFIGURE_REQUEST_PIC)
  set(CMAKE_REQUEST_PIC)
endif()

#foreach(PKG_WITH_INCL KSPACE PYTHON ML-IAP VORONOI COLVARS ML-HDNNP MDI MOLFILE NETCDF
#        PLUMED QMMM ML-QUIP SCAFACOS MACHDYN VTK KIM COMPRESS ML-PACE LEPTON EXTRA-COMMAND)
#  if(PKG_${PKG_WITH_INCL})
#    include(Packages/${PKG_WITH_INCL})
#  endif()
#endforeach()

# settings for misc packages and styles
#if(PKG_MISC)
#  option(SPPARKS_ASYNC_IMD "Asynchronous IMD processing" OFF)
#  mark_as_advanced(SPPARKS_ASYNC_IMD)
#  if(SPPARKS_ASYNC_IMD)
#    target_compile_definitions(spparks PRIVATE -DSPPARKS_ASYNC_IMD)
#    message(STATUS "Using IMD in asynchronous mode")
#  endif()
#endif()

# optionally enable building script wrappers using swig
option(WITH_SWIG "Build scripting language wrappers with SWIG" OFF)
if(WITH_SWIG)
  get_filename_component(SPPARKS_SWIG_DIR ${SPPARKS_SOURCE_DIR}/../tools/swig ABSOLUTE)
  add_subdirectory(${SPPARKS_SWIG_DIR} swig)
endif()

########################################################################
# make the standard math library overrideable and autodetected (for systems that don't have it)
find_library(STANDARD_MATH_LIB m DOC "Standard Math library")
mark_as_advanced(STANDARD_MATH_LIB)
if(STANDARD_MATH_LIB)
  target_link_libraries(spparks PRIVATE ${STANDARD_MATH_LIB})
endif()

######################################
# Generate Basic Style files
######################################
include(StyleHeaderUtils)
RegisterStyles(${SPPARKS_SOURCE_DIR})

##############################################
# add sources of enabled packages
############################################
foreach(PKG ${STANDARD_PACKAGES})
  set(${PKG}_SOURCES_DIR ${SPPARKS_SOURCE_DIR}/${PKG})

  file(GLOB ${PKG}_SOURCES CONFIGURE_DEPENDS ${${PKG}_SOURCES_DIR}/[^.]*.cpp)
  file(GLOB ${PKG}_HEADERS CONFIGURE_DEPENDS ${${PKG}_SOURCES_DIR}/[^.]*.h)

  # check for package files in src directory due to old make system
  DetectBuildSystemConflict(${SPPARKS_SOURCE_DIR} ${${PKG}_SOURCES} ${${PKG}_HEADERS})

  if(PKG_${PKG})
    # detects styles in package and adds them to global list
    RegisterStyles(${${PKG}_SOURCES_DIR})

    target_sources(spparks PRIVATE ${${PKG}_SOURCES})
    target_include_directories(spparks PRIVATE ${${PKG}_SOURCES_DIR})
  endif()

  RegisterPackages(${${PKG}_SOURCES_DIR})
endforeach()

# dedicated check for entire contents of accelerator packages
foreach(PKG ${SUFFIX_PACKAGES})
  set(${PKG}_SOURCES_DIR ${SPPARKS_SOURCE_DIR}/${PKG})

  file(GLOB ${PKG}_SOURCES CONFIGURE_DEPENDS ${${PKG}_SOURCES_DIR}/[^.]*.cpp)
  file(GLOB ${PKG}_HEADERS CONFIGURE_DEPENDS ${${PKG}_SOURCES_DIR}/[^.]*.h)

  # check for package files in src directory due to old make system
  DetectBuildSystemConflict(${SPPARKS_SOURCE_DIR} ${${PKG}_SOURCES} ${${PKG}_HEADERS})

  RegisterPackages(${${PKG}_SOURCES_DIR})
endforeach()

##############################################
# add lib sources of (simple) enabled packages
############################################
foreach(PKG_LIB H5MD)
  if(PKG_${PKG_LIB})
    string(TOLOWER "${PKG_LIB}" PKG_LIB)
    file(GLOB_RECURSE ${PKG_LIB}_SOURCES CONFIGURE_DEPENDS
      ${SPPARKS_LIB_SOURCE_DIR}/${PKG_LIB}/[^.]*.c ${SPPARKS_LIB_SOURCE_DIR}/${PKG_LIB}/[^.]*.cpp)
    add_library(${PKG_LIB} STATIC ${${PKG_LIB}_SOURCES})
    set_target_properties(${PKG_LIB} PROPERTIES OUTPUT_NAME spparks_${PKG_LIB}${SPPARKS_MACHINE})
    target_link_libraries(spparks PRIVATE ${PKG_LIB})
    if(PKG_LIB STREQUAL "h5md")
      target_include_directories(h5md PUBLIC ${SPPARKS_LIB_SOURCE_DIR}/h5md/include ${HDF5_INCLUDE_DIRS})
    else()
      target_include_directories(${PKG_LIB} PUBLIC ${SPPARKS_LIB_SOURCE_DIR}/${PKG_LIB})
    endif()
  endif()
endforeach()

if(PKG_H5MD)
  include(Packages/H5MD)
endif()

# link with -ldl or equivalent for plugin loading; except on Windows
if(NOT ${CMAKE_SYSTEM_NAME} STREQUAL "Windows")
   target_link_libraries(spparks PRIVATE ${CMAKE_DL_LIBS})
endif()

######################################################################
# the windows version of SPPARKS requires a couple extra libraries
# and the MPI library - if use - has to be linked right before those
# and after everything else that is compiled locally
######################################################################
if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
  target_link_libraries(spparks PRIVATE "wsock32;psapi")
endif()

######################################################
# Generate style headers based on global list of
# styles registered during package selection
# Generate packages headers from all packages
######################################################
set(SPPARKS_STYLE_HEADERS_DIR ${CMAKE_CURRENT_BINARY_DIR}/styles)
GenerateStyleHeaders(${SPPARKS_STYLE_HEADERS_DIR})
GeneratePackagesHeaders(${SPPARKS_STYLE_HEADERS_DIR})

target_include_directories(spparks PRIVATE ${SPPARKS_STYLE_HEADERS_DIR})

######################################
# Generate spkinstalledpkgs.h
######################################
set(temp "#ifndef LMP_INSTALLED_PKGS_H\n#define LMP_INSTALLED_PKGS_H\n")
set(temp "${temp}const char * SPPARKS_NS::SPPARKS::installed_packages[] =  {\n")
set(temp_PKG_LIST ${STANDARD_PACKAGES} ${SUFFIX_PACKAGES})
list(SORT temp_PKG_LIST)
foreach(PKG ${temp_PKG_LIST})
    if(PKG_${PKG})
        set(temp "${temp}  \"${PKG}\",\n")
    endif()
endforeach()
set(temp "${temp}  NULL\n};\n#endif\n\n")
message(STATUS "Generating spkinstalledpkgs.h...")
file(WRITE "${SPPARKS_STYLE_HEADERS_DIR}/spkinstalledpkgs.h.tmp" "${temp}" )
execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different "${SPPARKS_STYLE_HEADERS_DIR}/spkinstalledpkgs.h.tmp" "${SPPARKS_STYLE_HEADERS_DIR}/spkinstalledpkgs.h")

######################################
# Generate spkgitversion.h
######################################
add_custom_target(gitversion COMMAND ${CMAKE_COMMAND}
  -DSPPARKS_DIR="${SPPARKS_DIR}"
  -DGIT_EXECUTABLE="${GIT_EXECUTABLE}"
  -DGIT_FOUND="${GIT_FOUND}"
  -DSPPARKS_STYLE_HEADERS_DIR="${SPPARKS_STYLE_HEADERS_DIR}"
  -P ${CMAKE_CURRENT_SOURCE_DIR}/Modules/generate_spkgitversion.cmake)
set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${SPPARKS_STYLE_HEADERS_DIR}/gitversion.h)
add_dependencies(spparks gitversion)

###########################################
# Actually add executable and lib to build
############################################
get_property(LANGUAGES GLOBAL PROPERTY ENABLED_LANGUAGES)
list(FIND LANGUAGES "Fortran" _index)
if(_index GREATER -1)
  target_link_libraries(spparks PRIVATE ${CMAKE_Fortran_IMPLICIT_LINK_LIBRARIES})
endif()
set(SPPARKS_CXX_HEADERS app.h cluster.h comm_lattice.h comm_off_lattice.h diag.h domain.h error.h finish.h 
   groups.h image.h input.h irregular.h kdtree.h lattice.h library.h memory.h output.h pair.h pointers.h 
   potential.h region.h set.h solve.h spktype.h spparks.h timer.h)
#set(SPPARKS_FMT_HEADERS core.h format.h)

set_target_properties(spparks PROPERTIES OUTPUT_NAME spparks${SPPARKS_MACHINE})
set_target_properties(spparks PROPERTIES SOVERSION ${SOVERSION})
set_target_properties(spparks PROPERTIES PREFIX "lib")
target_include_directories(spparks PUBLIC $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/spparks>)
file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks/fmt)
foreach(_HEADER ${SPPARKS_CXX_HEADERS})
  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks/${_HEADER} COMMAND ${CMAKE_COMMAND} -E copy_if_different ${SPPARKS_SOURCE_DIR}/${_HEADER} ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks/${_HEADER} DEPENDS ${SPPARKS_SOURCE_DIR}/${_HEADER})
  add_custom_target(${_HEADER} DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks/${_HEADER})
  add_dependencies(spparks ${_HEADER})
  if(BUILD_SHARED_LIBS)
    install(FILES ${SPPARKS_SOURCE_DIR}/${_HEADER} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/spparks)
  endif()
endforeach()
foreach(_HEADER ${SPPARKS_FMT_HEADERS})
  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks/fmt/${_HEADER} COMMAND ${CMAKE_COMMAND} -E copy_if_different ${SPPARKS_SOURCE_DIR}/fmt/${_HEADER} ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks/fmt/${_HEADER} DEPENDS ${SPPARKS_SOURCE_DIR}/fmt/${_HEADER})
  add_custom_target(fmt_${_HEADER} DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/includes/spparks/fmt/${_HEADER})
  add_dependencies(spparks fmt_${_HEADER})
  if(BUILD_SHARED_LIBS)
    install(FILES ${SPPARKS_SOURCE_DIR}/fmt/${_HEADER} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/spparks/fmt)
  endif()
endforeach()
target_include_directories(spparks INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/includes>)
add_library(SPPARKS::spparks ALIAS spparks)
get_target_property(SPPARKS_DEFINES spparks INTERFACE_COMPILE_DEFINITIONS)
set(SPPARKS_API_DEFINES)
foreach(_DEF ${SPPARKS_DEFINES})
  set(SPPARKS_API_DEFINES "${SPPARKS_API_DEFINES} -D${_DEF}")
endforeach()
if(BUILD_SHARED_LIBS)
  install(TARGETS spparks EXPORT SPPARKS_Targets
          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
  if(NOT BUILD_MPI)
    install(TARGETS mpi_stubs EXPORT SPPARKS_Targets
            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
  endif()
  configure_file(pkgconfig/libspparks.pc.in ${CMAKE_CURRENT_BINARY_DIR}/libspparks${SPPARKS_MACHINE}.pc @ONLY)
  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libspparks${SPPARKS_MACHINE}.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
  install(EXPORT SPPARKS_Targets FILE SPPARKS_Targets.cmake NAMESPACE SPPARKS:: DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/SPPARKS)
  include(CMakePackageConfigHelpers)
  configure_file(SPPARKSConfig.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/SPPARKSConfig.cmake @ONLY)
  write_basic_package_version_file("SPPARKSConfigVersion.cmake" VERSION ${PROJECT_VERSION} COMPATIBILITY ExactVersion)
  install(FILES "${CMAKE_CURRENT_BINARY_DIR}/SPPARKSConfig.cmake" "${CMAKE_CURRENT_BINARY_DIR}/SPPARKSConfigVersion.cmake" DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/SPPARKS)
endif()
install(FILES ${SPPARKS_DOC_DIR}/spparks.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 RENAME ${SPPARKS_BINARY}.1)

include(Tools)
include(Documentation)

###############################################################################
# Install bench, potential and force field files in data directory
###############################################################################


###############################################################################
# Install SPPARKS lib and python module into site-packages folder with
# "install-python" target.  Behaves exactly like "make install-python" for
# conventional build.  Only available, if a shared library is built.
# This is primarily for people that only want to use the Python wrapper.
###############################################################################
if(BUILD_SHARED_LIBS)
  # backward compatibility
  find_package(Python COMPONENTS Interpreter)
  if(BUILD_IS_MULTI_CONFIG)
    set(MY_BUILD_DIR ${CMAKE_BINARY_DIR}/$<CONFIG>)
  else()
    set(MY_BUILD_DIR ${CMAKE_BINARY_DIR})
  endif()
  set(LIBSPPARKS_SHARED_BINARY ${MY_BUILD_DIR}/libspparks${SPPARKS_MACHINE}${CMAKE_SHARED_LIBRARY_SUFFIX})
  if(Python_EXECUTABLE)
    add_custom_target(
      install-python ${Python_EXECUTABLE} ${SPPARKS_PYTHON_DIR}/install.py -p ${SPPARKS_PYTHON_DIR}/spparks
      -l ${LIBSPPARKS_SHARED_BINARY} -w ${MY_BUILD_DIR} -v ${SPPARKS_SOURCE_DIR}/version.h
      COMMENT "Installing SPPARKS Python module")
  else()
    add_custom_target(
      install-python
      ${CMAKE_COMMAND} -E echo "Must have Python installed to install the SPPARKS Python module")
  endif()
else()
  add_custom_target(
    install-python
    ${CMAKE_COMMAND} -E echo "Must build SPPARKS as a shared library to use the Python module")
endif()

include(Testing)
include(CodeCoverage)
include(CodingStandard)
find_package(ClangFormat 11.0 QUIET)

if(ClangFormat_FOUND)
  add_custom_target(format-src
    COMMAND ${ClangFormat_EXECUTABLE} --verbose -i -style=file *.cpp *.h */*.cpp */*.h
    WORKING_DIRECTORY ${SPPARKS_SOURCE_DIR})
endif()

get_target_property(DEFINES spparks COMPILE_DEFINITIONS)
if(BUILD_IS_MULTI_CONFIG)
  set(SPPARKS_BUILD_TYPE "Multi-Config")
else()
  set(SPPARKS_BUILD_TYPE ${CMAKE_BUILD_TYPE})
endif()
include(FeatureSummary)
feature_summary(DESCRIPTION "The following tools and libraries have been found and configured:" WHAT PACKAGES_FOUND)
if(GIT_FOUND AND EXISTS ${SPPARKS_DIR}/.git)
  execute_process(COMMAND ${GIT_EXECUTABLE} describe --dirty=-modified --always
    OUTPUT_VARIABLE GIT_DESCRIBE
    ERROR_QUIET
    WORKING_DIRECTORY ${SPPARKS_DIR}
    OUTPUT_STRIP_TRAILING_WHITESPACE)
endif()
message(STATUS "<<< Build configuration >>>
   SPPARKS Version:   ${PROJECT_VERSION} ${GIT_DESCRIBE}
   Operating System: ${CMAKE_SYSTEM_NAME} ${CMAKE_LINUX_DISTRO} ${CMAKE_DISTRO_VERSION}
   CMake Version:    ${CMAKE_VERSION}
   Build type:       ${SPPARKS_BUILD_TYPE}
   Install path:     ${CMAKE_INSTALL_PREFIX}
   Generator:        ${CMAKE_GENERATOR} using ${CMAKE_MAKE_PROGRAM}")
if(CMAKE_CROSSCOMPILING)
  message(STATUS "Cross compiling on ${CMAKE_HOST_SYSTEM}")
endif()
###############################################################################
# Print package summary
###############################################################################
set(ENABLED_PACKAGES)
foreach(PKG ${STANDARD_PACKAGES} ${SUFFIX_PACKAGES})
  if(PKG_${PKG})
    list(APPEND ENABLED_PACKAGES ${PKG})
  endif()
endforeach()
if(ENABLED_PACKAGES)
  list(SORT ENABLED_PACKAGES)
else()
  set(ENABLED_PACKAGES "<None>")
endif()
message(STATUS "Enabled packages: ${ENABLED_PACKAGES}")

message(STATUS "<<< Compilers and Flags: >>>
-- C++ Compiler:     ${CMAKE_CXX_COMPILER}
      Type:          ${CMAKE_CXX_COMPILER_ID}
      Version:       ${CMAKE_CXX_COMPILER_VERSION}
      C++ Standard:  ${CMAKE_CXX_STANDARD}
      C++ Flags:    ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_${BTYPE}}
      Defines:       ${DEFINES}")
if(CMAKE_CXX_COMPILER_LAUNCHER)
  message(STATUS "      Launcher:      ${CMAKE_CXX_COMPILER_LAUNCHER}")
endif()
get_target_property(OPTIONS spparks COMPILE_OPTIONS)
if(OPTIONS)
  message("      Options:       ${OPTIONS}")
endif()
get_property(LANGUAGES GLOBAL PROPERTY ENABLED_LANGUAGES)
list(FIND LANGUAGES "Fortran" _index)
if(_index GREATER -1)
  message(STATUS "Fortran Compiler: ${CMAKE_Fortran_COMPILER}
      Type:          ${CMAKE_Fortran_COMPILER_ID}
      Version:       ${CMAKE_Fortran_COMPILER_VERSION}
      Fortran Flags:${CMAKE_Fortran_FLAGS} ${CMAKE_Fortran_FLAGS_${BTYPE}}")
endif()
list(FIND LANGUAGES "C" _index)
if(_index GREATER -1)
  message(STATUS "C compiler:       ${CMAKE_C_COMPILER}
      Type:          ${CMAKE_C_COMPILER_ID}
      Version:       ${CMAKE_C_COMPILER_VERSION}
      C Flags:      ${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${BTYPE}}")
  if(CMAKE_C_COMPILER_LAUNCHER)
    message(STATUS "      Launcher:      ${CMAKE_C_COMPILER_LAUNCHER}")
  endif()
endif()
message(STATUS "<<< Linker flags: >>>")
message(STATUS "Executable name:  ${SPPARKS_BINARY}")
get_target_property(OPTIONS spparks LINK_OPTIONS)
if(OPTIONS)
  message(STATUS "Linker options:   ${OPTIONS}")
endif()
if(CMAKE_EXE_LINKER_FLAGS)
  message(STATUS "Executable linker flags: ${CMAKE_EXE_LINKER_FLAGS}")
endif()
if(BUILD_SHARED_LIBS)
  message(STATUS "Shared library flags:    ${CMAKE_SHARED_LINKER_FLAGS}")
else()
  message(STATUS "Static library flags:    ${CMAKE_STATIC_LINKER_FLAGS}")
endif()
if(BUILD_MPI)
  message(STATUS "<<< MPI flags >>>
-- MPI_defines:      ${MPI_CXX_COMPILE_DEFINITIONS}
-- MPI includes:     ${MPI_CXX_INCLUDE_PATH}
-- MPI libraries:    ${MPI_CXX_LIBRARIES};${MPI_Fortran_LIBRARIES}")
endif()
if(BUILD_DOC)
  message(STATUS "<<< Building HTML Manual >>>")
endif()
if(BUILD_TOOLS)
  message(STATUS "<<< Building Tools >>>")
endif()
if(ENABLE_TESTING)
  message(STATUS "<<< Building Unit Tests >>>")
  if(ENABLE_COVERAGE)
    message(STATUS "Collecting code coverage data")
  endif()
endif()
